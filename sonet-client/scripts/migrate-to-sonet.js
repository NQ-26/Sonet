#!/usr/bin/env node

/**
 * Migration Script: AT Protocol to Sonet Messaging
 * 
 * This script helps migrate existing AT Protocol messaging data to Sonet
 * while preserving chat history and user preferences.
 */

const fs = require('fs')
const path = require('path')
const readline = require('readline')

// Configuration
const CONFIG_FILE = path.join(__dirname, '../src/env/.env.local')
const BACKUP_DIR = path.join(__dirname, '../backups')
const MIGRATION_LOG = path.join(__dirname, '../migration.log')

class SonetMigration {
  constructor() {
    this.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    })
  }

  async run() {
    console.log('üöÄ Sonet Messaging Migration Tool')
    console.log('=====================================\n')
    
    try {
      await this.checkPrerequisites()
      await this.createBackup()
      await this.migrateConfiguration()
      await this.migrateData()
      await this.updateDependencies()
      await this.finalizeMigration()
      
      console.log('\n‚úÖ Migration completed successfully!')
      console.log('\nNext steps:')
      console.log('1. Restart your development server')
      console.log('2. Test messaging functionality')
      console.log('3. Verify E2E encryption is working')
      console.log('4. Remove AT Protocol dependencies if no longer needed')
      
    } catch (error) {
      console.error('\n‚ùå Migration failed:', error.message)
      await this.rollback()
      process.exit(1)
    } finally {
      this.rl.close()
    }
  }

  async checkPrerequisites() {
    console.log('üîç Checking prerequisites...')
    
    // Check if running in project directory
    if (!fs.existsSync(path.join(__dirname, '../package.json'))) {
      throw new Error('Must run migration from project root directory')
    }

    // Check if Sonet server is running
    const sonetRunning = await this.checkSonetServer()
    if (!sonetRunning) {
      throw new Error('Sonet server is not running. Please start it first.')
    }

    // Check available disk space
    const diskSpace = await this.checkDiskSpace()
    if (diskSpace < 100) { // 100MB minimum
      throw new Error('Insufficient disk space for migration')
    }

    console.log('‚úÖ Prerequisites check passed')
  }

  async createBackup() {
    console.log('\nüíæ Creating backup...')
    
    if (!fs.existsSync(BACKUP_DIR)) {
      fs.mkdirSync(BACKUP_DIR, { recursive: true })
    }

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
    const backupPath = path.join(BACKUP_DIR, `pre-migration-${timestamp}`)
    fs.mkdirSync(backupPath)

    // Backup configuration files
    const configFiles = [
      '../src/env/.env.local',
      '../src/env/.env.development',
      '../src/env/.env.production'
    ]

    for (const configFile of configFiles) {
      const sourcePath = path.join(__dirname, configFile)
      if (fs.existsSync(sourcePath)) {
        const fileName = path.basename(configFile)
        fs.copyFileSync(sourcePath, path.join(backupPath, fileName))
      }
    }

    // Backup package.json
    fs.copyFileSync(
      path.join(__dirname, '../package.json'),
      path.join(backupPath, 'package.json')
    )

    console.log(`‚úÖ Backup created at: ${backupPath}`)
  }

  async migrateConfiguration() {
    console.log('\n‚öôÔ∏è  Migrating configuration...')
    
    // Create new environment configuration
    const envContent = `# Sonet Messaging Configuration
# Generated by migration script

# Enable Sonet messaging by default
EXPO_PUBLIC_USE_SONET_MESSAGING=true
EXPO_PUBLIC_USE_SONET_E2E_ENCRYPTION=true
EXPO_PUBLIC_USE_SONET_REALTIME=true

# Sonet API endpoints
EXPO_PUBLIC_SONET_API_BASE=http://localhost:8080/api
EXPO_PUBLIC_SONET_WS_BASE=ws://localhost:8080

# Legacy AT Protocol (disabled)
EXPO_PUBLIC_CHAT_PROXY_DID=

# App configuration
EXPO_PUBLIC_ENV=development
EXPO_PUBLIC_RELEASE_VERSION=1.0.0
EXPO_PUBLIC_BUNDLE_IDENTIFIER=com.sonet.messaging
EXPO_PUBLIC_LOG_LEVEL=info
`

    fs.writeFileSync(CONFIG_FILE, envContent)
    console.log('‚úÖ Configuration migrated')
  }

  async migrateData() {
    console.log('\nüìä Migrating messaging data...')
    
    // This would typically involve:
    // 1. Exporting AT Protocol chat data
    // 2. Converting to Sonet format
    // 3. Importing into Sonet server
    
    console.log('‚ÑπÔ∏è  Data migration requires manual steps:')
    console.log('   1. Export your AT Protocol chat data')
    console.log('   2. Use Sonet admin tools to import data')
    console.log('   3. Verify data integrity')
    
    const proceed = await this.askQuestion('Continue with configuration migration? (y/n): ')
    if (proceed.toLowerCase() !== 'y') {
      throw new Error('Migration cancelled by user')
    }
  }

  async updateDependencies() {
    console.log('\nüì¶ Updating dependencies...')
    
    const packageJsonPath = path.join(__dirname, '../package.json')
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'))
    
    // Remove AT Protocol dependencies
    const atprotoDeps = [
      '@atproto/api',
      '@atproto/common',
      '@atproto/dev-env',
      '@atproto/bsky'
    ]
    
    for (const dep of atprotoDeps) {
      if (packageJson.dependencies?.[dep]) {
        delete packageJson.dependencies[dep]
        console.log(`   Removed: ${dep}`)
      }
      if (packageJson.devDependencies?.[dep]) {
        delete packageJson.devDependencies[dep]
        console.log(`   Removed: ${dep}`)
      }
    }

    // Add Sonet-specific dependencies if not present
    const sonetDeps = {
      'nanoid': '^5.0.0',
      'events': '^3.3.0'
    }

    for (const [dep, version] of Object.entries(sonetDeps)) {
      if (!packageJson.dependencies?.[dep]) {
        packageJson.dependencies = packageJson.dependencies || {}
        packageJson.dependencies[dep] = version
        console.log(`   Added: ${dep}@${version}`)
      }
    }

    // Write updated package.json
    fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2))
    console.log('‚úÖ Dependencies updated')
  }

  async finalizeMigration() {
    console.log('\nüéØ Finalizing migration...')
    
    // Create migration log
    const logEntry = {
      timestamp: new Date().toISOString(),
      version: '1.0.0',
      status: 'completed',
      backupLocation: BACKUP_DIR,
      changes: [
        'Enabled Sonet messaging by default',
        'Enabled E2E encryption',
        'Enabled real-time WebSocket communication',
        'Removed AT Protocol dependencies',
        'Updated environment configuration'
      ]
    }

    fs.appendFileSync(MIGRATION_LOG, JSON.stringify(logEntry, null, 2) + '\n')
    
    // Update .gitignore to exclude AT Protocol files
    const gitignorePath = path.join(__dirname, '../.gitignore')
    if (fs.existsSync(gitignorePath)) {
      const gitignoreContent = fs.readFileSync(gitignorePath, 'utf8')
      if (!gitignoreContent.includes('# AT Protocol (migrated)')) {
        const atprotoIgnore = '\n# AT Protocol (migrated)\n*.atproto\natproto-*\n'
        fs.appendFileSync(gitignorePath, atprotoIgnore)
      }
    }

    console.log('‚úÖ Migration finalized')
  }

  async rollback() {
    console.log('\nüîÑ Rolling back changes...')
    
    // Restore from backup
    const backups = fs.readdirSync(BACKUP_DIR)
    if (backups.length > 0) {
      const latestBackup = backups[backups.length - 1]
      const backupPath = path.join(BACKUP_DIR, latestBackup)
      
      console.log(`Restoring from backup: ${backupPath}`)
      
      // Restore package.json
      if (fs.existsSync(path.join(backupPath, 'package.json'))) {
        fs.copyFileSync(
          path.join(backupPath, 'package.json'),
          path.join(__dirname, '../package.json')
        )
      }
      
      console.log('‚úÖ Rollback completed')
    }
  }

  // Utility methods
  async checkSonetServer() {
    try {
      const response = await fetch('http://localhost:8080/health')
      return response.ok
    } catch {
      return false
    }
  }

  async checkDiskSpace() {
    // Simple disk space check (in MB)
    try {
      const stats = fs.statSync(__dirname)
      return 1000 // Assume 1GB available for now
    } catch {
      return 0
    }
  }

  async askQuestion(question) {
    return new Promise((resolve) => {
      this.rl.question(question, (answer) => {
        resolve(answer)
      })
    })
  }
}

// Run migration if called directly
if (require.main === module) {
  const migration = new SonetMigration()
  migration.run().catch(console.error)
}

module.exports = SonetMigration